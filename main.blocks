<xml xmlns="https://developers.google.com/blockly/xml"><block type="pxt-on-start" id="Z?7:n+fx]9!)^F9C*x|P" x="0" y="0"><statement name="HANDLER"><block type="typescript_statement" id="Bg4fUzaB`s|;AUi;M#-S" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="namespace limits {" line1="" line2="// PCA9685 address definitions. " line3="    const CHIP_ADDRESS: number = 0x6A;              // Default Kitronik Chip address" line4="    const REG_MODE1: number = 0x00;                 // Mode 1 register address " line5="    const REG_MODE2: number = 0x01;                 // Mode 2 register address " line6="    const REG_SUB_ADR1: number = 0x02;              // Sub address register 1 address" line7="    const REG_SUB_ADR2: number = 0x03;              // Sub address register 2 address" line8="    const REG_SUB_ADR3: number = 0x04;              // Sub address register 3 address" line9="    const REG_ALL_CALL: number = 0x05;              // All call address register" line10="    const REG_SERVO1_REG_BASE: number = 0x06;       // Servo 1 base address " line11="" line12="    const REG_ALL_LED_ON_L: number = 0xFA;          // All LED on low register address" line13="    const REG_ALL_LED_ON_H: number = 0xFB;          // All LED on high register address" line14="    const REG_ALL_LED_OFF_L: number = 0xFC;         // All LED off low register address" line15="    const REG_ALL_LED_OFF_H: number = 0xFD;         // All LED off high register address " line16="    const REG_PRE_SCALE: number = 0xFE;             // Pre-scaler register address" line17="" line18="    const PWM_FREQUENCY: number = 0x1E;             // Pre-scaler value for 50Hz" line19="" line20="    " line21="// If you wanted to write some code that stepped through the servos then this is the BASe and size to do that &#9;" line22="&#9;let Servo1RegBase = 0x08 " line23="    let ServoRegDistance = 4" line24="&#9;//To get the PWM pulses to the correct size and zero offset these are the default numbers. " line25="    let ServoMultiplier = 226" line26="    let ServoZeroOffset = 0x66" line27="" line28="    let PCA9865_init: boolean = false //a flag to allow us to initialise without explicitly calling the secret incantation" line29="" line30="    //nice big list of servos for the block to use. These represent register offsets in the PCA9865" line31="    export enum Servos {" line32="        Servo1 = 0x08," line33="        Servo2 = 0x0C," line34="        Servo3 = 0x10," line35="        Servo4 = 0x14," line36="        Servo5 = 0x18," line37="        Servo6 = 0x1C," line38="        Servo7 = 0x20," line39="        Servo8 = 0x24," line40="        Servo9 = 0x28," line41="        Servo10 = 0x2C," line42="        Servo11 = 0x30," line43="        Servo12 = 0x34," line44="        Servo13 = 0x38," line45="        Servo14 = 0x3C," line46="        Servo15 = 0x40," line47="        Servo16 = 0x44," line48="    }" line49="" line50="&#9;export enum BoardAddresses{" line51="&#9;&#9;Board1 = 0x6A," line52="&#9;}" line53="" line54="    export enum PulseRange {" line55="        R500_2500uS = 1," line56="        R600_2400uS = 2," line57="        R700_2300uS = 3," line58="        R800_2200uS = 4," line59="        R900_2100uS = 5," line60="        R1000_2000uS = 6," line61="    }" line62="" line63="    //Trim the servo pulses. These are here for advanced users, and not exposed to blocks." line64="    //It appears that servos I've tested are actually expecting 0.5 - 2.5mS pulses, " line65="    //not the widely reported 1-2mS " line66="    //that equates to multiplier of 226, and offset of 0x66" line67="    // a better trim function that does the maths for the end user could be exposed, the basics are here " line68="&#9;// for reference" line69="" line70="    export function TrimServoMultiplier(Value: number) {" line71="        if (Value &lt; 113) {" line72="            ServoMultiplier = 113" line73="        }" line74="        else {" line75="            if (Value &gt; 226) {" line76="                ServoMultiplier = 226" line77="            }" line78="            else {" line79="                ServoMultiplier = Value" line80="            }" line81="        }" line82="    }" line83="    export function TrimServoZeroOffset(Value: number) {" line84="        if (Value &lt; 0x66) {" line85="            ServoZeroOffset = 0x66" line86="        }" line87="        else {" line88="            if (Value &gt; 0xCC) {" line89="                ServoZeroOffset = 0xCC" line90="            }" line91="            else {" line92="                ServoZeroOffset = Value" line93="            }" line94="        }" line95="    }" line96="" line97="&#9;/*" line98="&#9;* This initialisation function sets up the PCA9865 servo driver chip. " line99="    * The PCA9685 comes out of reset in low power mode with the internal oscillator off with no output signals, this allows writes to the pre-scaler register." line100="    * The pre-scaler register is set to 50Hz producing a refresh rate or frame period of 20mS which inturn makes each bit of the 4096 count equal to 4.88uS." line101="    * Sets the 16 LED ON registers to 0x00 which starts the high output pulse start at the beginning of each 20mS frame period." line102="    * Sets the 16 LED OFF registers to 0x133 (4.88uS x 1500) which ends the high output pulse 1.5mS into the frame period. This places all servo motors at 90 degrees or centre travel." line103="    * It is these LED OFF registers that will be modified to set the pulse high end time to vary the pulse width and the position of the attached servo motor. " line104="    * Sets the mode1 register to 0x01 to disable restart, use internal clock, disable register auto increment, select normal (run) mode, disable sub addresses and allow LED all call addresses." line105="    * Finally the initialised flag will be set true." line106="&#9;* This function should not be called directly by a user, the first servo write will call it." line107="    * This function initialises all 16 LED ON and LED OFF registers by using a single block write to the 'all LED' addresses." line108="&#9;*/" line109="&#9;function initialisation(): void {" line110="        let buf = pins.createBuffer(2)                      // Create a buffer for i2c bus data" line111="        buf[0] = REG_PRE_SCALE;                             // Point at pre-scaler register" line112="        buf[1] = PWM_FREQUENCY;                             // Set PWM frequency to 50Hz or repetition rate of 20mS" line113="        pins.i2cWriteBuffer(CHIP_ADDRESS, buf, false);      // Write to PCA9865 " line114="        buf[0] = REG_ALL_LED_ON_L;                          // " line115="        buf[1] = 0x00;                                      // Start high pulse at 0 (0-0x199) " line116="        pins.i2cWriteBuffer(CHIP_ADDRESS, buf, false);      // Write to PCA9865" line117="        buf[0] = REG_ALL_LED_ON_H;                          //  " line118="        buf[1] = 0x00;                                      // Start each frame with pulse high" line119="        pins.i2cWriteBuffer(CHIP_ADDRESS, buf, false);      // Write to PCA9865" line120="        buf[0] = REG_ALL_LED_OFF_L;                         //" line121="        buf[1] = 0x23;                                      // End high pulse at mid range 1.5mS = 1500/4.88uS = 307 (0x133)" line122="        pins.i2cWriteBuffer(CHIP_ADDRESS, buf, false);      // Write to PCA9865" line123="        buf[0] = REG_ALL_LED_OFF_H;                         //" line124="        buf[1] = 0x01;                                      // End high pulse at mid range 1.5mS = 1500/4.88uS = 307 (0x133)" line125="        pins.i2cWriteBuffer(CHIP_ADDRESS, buf, false);      // Write to PCA9865" line126="        buf[0] = REG_MODE1;                                 //" line127="        buf[1] = 0x01;                                      // Normal mode, start oscillator and allow LED all call registers" line128="        pins.i2cWriteBuffer(CHIP_ADDRESS, buf, false)       // Write to PCA9865" line129="        PCA9865_init = true;                                // The PCA9865 is now initialised, no need to do it again" line130="    }" line131="&#9;" line132="    /**" line133="     * Sets the requested servo to the reguested angle." line134="&#9; * if the PCA has not yet been initialised calls the initialisation routine" line135="&#9; *" line136="     * @param Servo Which servo to set" line137="&#9; * @param degrees the angle to set the servo to" line138="     */" line139="    //% blockId=I2C_servo_write" line140="    //% block=&quot;set%Servo|to%degrees&quot;" line141="&#9;//% degrees.min=0 degrees.max=180" line142="&#9;" line143="    export function servoWrite(Servo: Servos, degrees: number): void {" line144="        if (PCA9865_init == false) {" line145="            initialisation()" line146="        }" line147="        let buf2 = pins.createBuffer(2)" line148="        let HighByte = false" line149="        let deg100 = degrees * 100" line150="        let PWMVal100 = deg100 * ServoMultiplier" line151="        let PWMVal = PWMVal100 / 10000" line152="        PWMVal = Math.floor(PWMVal)" line153="        PWMVal = PWMVal + ServoZeroOffset" line154="        if (PWMVal &gt; 0xFF) {" line155="            HighByte = true" line156="        }" line157="        buf2[0] = Servo" line158="        buf2[1] = PWMVal" line159="        pins.i2cWriteBuffer(CHIP_ADDRESS, buf2, false)" line160="        if (HighByte) {" line161="            buf2[0] = Servo + 1" line162="            buf2[1] = 0x01" line163="        }" line164="        else {" line165="            buf2[0] = Servo + 1" line166="            buf2[1] = 0x00" line167="        }" line168="        pins.i2cWriteBuffer(CHIP_ADDRESS, buf2, false)" line169="    }" line170="}" numlines="171"></mutation></block></statement></block></xml>